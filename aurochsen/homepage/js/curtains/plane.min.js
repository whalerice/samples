import{Plane,Vec2}from"./src/index.mjs";export const initCurtain=(t,e,n)=>{function o(t,e){r.copy(a);const n=new Vec2;if(t.targetTouches?n.set(t.targetTouches[0].clientX,t.targetTouches[0].clientY):n.set(t.clientX,t.clientY),a.set(l.lerp(a.x,n.x,.3),l.lerp(a.y,n.y,.3)),e){const t=e.mouseToPlaneCoords(a);if(t.y>-1.25&&(e.uniforms.mousePosition.value=t,r.x&&r.y)){let t=Math.sqrt(Math.pow(a.x-r.x,2)+Math.pow(a.y-r.y,2))/30;t=Math.min(4,t),t>=s.max&&(s.max=t)}}}function i(t,e){const n=t.getBoundingRect(),o=n.width,i=n.height;e.width=o,e.height=i;const a=e.getContext("2d");a.width=o,a.height=i}const a=new Vec2,r=new Vec2,s={max:0,applied:0},l=t;l.onError(function(){document.body.classList.add("no-curtains")}).onContextLost(()=>{l.restoreContext()});const u="precision mediump float;\n\n\t// default mandatory variables\n\tattribute vec3 aVertexPosition;\n\tattribute vec2 aTextureCoord;\n\n\tuniform mat4 uMVMatrix;\n\tuniform mat4 uPMatrix;\n\n\t// custom variables\n\tvarying vec3 vVertexPosition;\n\tvarying vec3 vOriginalVertexPosition;\n\tvarying vec2 vTextureCoord;\n\n\tuniform float uMouseTime;\n\tuniform vec2 uMousePosition;\n\tuniform float uMouseMoveStrength;\n\n\n\tvoid main() {\n\n\t\tvec3 vertexPosition = aVertexPosition;\n\n\t\t// fix the curtain on top (y coord ranges from top : 1.0 to bottom : -1.0)\n\t\tfloat yCoordRatio = vertexPosition.y - 1.0;\n\n\n\t\tfloat distanceFromMouse = distance(vec2(uMousePosition.x, 0.0), vec2(vertexPosition.x, 0.0));\n\n\t\t//float waveSinusoid = cos(10.0 * 1.5 * ((1.0 / (distanceFromMouse - 2.0)) - (uMouseTime / 500.0)));\n\t\tfloat waveSinusoid = cos(35.0 * ((1.0 / (cos(distanceFromMouse) - 2.0)) - uMouseTime * 0.0015));\n\n\t\tfloat xAttenuation = ((2.0 - abs(uMousePosition.x - vertexPosition.x)) / 2.0);\n\t\tfloat yAttenuation = ((-1.0 * uMousePosition.y) + 1.0) / 2.0;\n\t\tif(uMousePosition.y <= -1.0) {\n\t\t\tyAttenuation = yAttenuation + (uMousePosition.y + 1.0) * 1.5;\n\t\t}\n\t\tyAttenuation = clamp(yAttenuation, 0.0, 1.0);\n\n\t\tfloat curtainEffect = yCoordRatio  * waveSinusoid * uMouseMoveStrength * xAttenuation * yAttenuation;\n\n\t\tfloat xDisplacement = abs(yCoordRatio) * sign(vertexPosition.x);\n\n\t\tvertexPosition.z +=  curtainEffect / 30.0;\n\t\tvertexPosition.x +=  curtainEffect * 1.5 * xDisplacement / 240.0;\n\n\t\tgl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);\n\n\t\t// varyings\n\t\tvTextureCoord = aTextureCoord;\n\t\tvVertexPosition = vertexPosition;\n\t\tvOriginalVertexPosition = aVertexPosition;\n\t}",c="precision mediump float;\n\n\tvarying vec3 vVertexPosition;\n\tvarying vec3 vOriginalVertexPosition;\n\tvarying vec2 vTextureCoord;\n\n\tuniform sampler2D curtainSampler;\n\tuniform sampler2D titleSampler;\n\n\n\tvec3 getNormal(vec3 pos, vec3 originalPos) {\n\t\tfloat diff = 0.25;\n\t\tvec3 neighbour1 = vec3(originalPos.x + diff, originalPos.y, originalPos.z);\n\t\tvec3 neighbour2 = vec3(originalPos.x, pos.y + diff, originalPos.z);\n\t\tvec3 tangent = (neighbour1 - pos);\n\t\tvec3 bitangent = (neighbour2 - pos);\n\t\treturn normalize(cross(tangent, bitangent));\n\t}\n\n\n\tvoid main() {\n\n\t\tvec2 textureCoords = vec2(vTextureCoord.x, vTextureCoord.y);\n\n\t\t// slides transitions\n\t\tvec4 finalColor = texture2D(curtainSampler, textureCoords);\n\t\tvec4 title = texture2D(titleSampler, textureCoords);\n\n\t\tfinalColor = mix(finalColor, title, title.a);\n\n\t\t//finalColor.rgb -= clamp(-vVertexPosition.z / 5.0, 0.0, 1.0);\n\t\t//finalColor.rgb += clamp(vVertexPosition.z / 5.0, 0.0, 1.0);\n\n\t\tvec3 normal = getNormal(vVertexPosition, vOriginalVertexPosition);\n\n\t\tvec3 lightPos = normalize(vec3(0.3, 0.3, 1.0));\n\t\tfloat light = smoothstep(0.45, 1.0, dot(normal, lightPos));\n\n\t\tfloat lightStrength = 0.35;\n\t\tfloat ambientLight = 1.0 - lightStrength;\n\t\tfinalColor.rgb = finalColor.rgb * light * lightStrength + finalColor.rgb * ambientLight;\n\n\t\t// handling premultiplied alpha\n\t\tfinalColor = vec4(finalColor.rgb * finalColor.a, finalColor.a);\n\n\t\tgl_FragColor = finalColor;\n\t}",m=document.getElementsByClassName(e),v={vertexShader:u,fragmentShader:c,widthSegments:50,heightSegments:37,uniforms:{mouseTime:{name:"uMouseTime",type:"1f",value:0},mousePosition:{name:"uMousePosition",type:"2f",value:a},mouseMoveStrength:{name:"uMouseMoveStrength",type:"1f",value:0}}},g=new Plane(l,m[0],v),x=document.createElement("canvas");x.setAttribute("data-sampler","titleSampler"),x.style.display="none",g.loadCanvas(x),g.onReady(()=>{const t=document.getElementById(n);t.addEventListener("mousemove",function(t){o(t,g)}),t.addEventListener("touchmove",function(t){o(t,g)},{passive:!0})}).onLoading(()=>{s.max=6}).onRender(()=>{g.uniforms.mouseTime.value++,s.applied+=.02*(s.max-s.applied),s.max+=.01*(0-s.max),g.uniforms.mouseMoveStrength.value=s.applied}).onReEnterView(()=>{g.textures[1].needUpdate()}).onAfterResize(()=>{i(g,x)})};